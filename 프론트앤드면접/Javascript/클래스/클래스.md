# 클래스 에 대해?

- 일급객체 이다
- 표현식 ,문으로 선언가능
- 반드시 new 키워드를 사용하여 인스턴스를 생성할수있다
- 프로토타입과 동일하게 생성자함수.protoype의 construcotr는 해당 클래스를 가리킨다
- extends와 super키워드를 제공한다.
- 클래스 내의 모든코드는 암묵적으로 strict mode가 지정된다. (생성자함수는 지정ㅌ)
- 클래스 내의 constructor는 메소드가 아니며 constructor내부에서 return시 무시됨
- 클래스 내의 내부메소드는 non-constructor이며 따라서 new 연산자와 함께 호출이 불가능하다
- 클래스 내의 consturctor안에서 생성한 프로퍼티는 public해서 외부에서 해당 변수를 접근가능

# 클래스의 호이스팅여부

- 함수로 평가된다
- 클래스 이전에는 참조할수 없다 (tdz) , 블록스코프에 같힘

## 클래스안에 메소드로 선언

- 프로토타입 메소드가 된다 (setter,getter동일)
- prototype 프로퍼티에 존재하지않음

## 클래스안에 함수로 선언 (사용하지마라)

- 프로토타입 메소드가 아닌 인스턴스 메소드가 됨 (메모리 낭비 요인)

## 클래스 안에 화살표 함수로 선언 (사용하지마라)

- this는 상위스코프를 가리킴 (클래스자체)
- 인스턴스 메소드가 됨 (메모리낭비)

## 클래스 안에 정적 메소드로 선언 (static)

- 인스턴스를 생성하지 않아도 호출 가능
- 클래스 프로퍼티로 저장
- 프로토타입 체인상에 존재하지않는다.

## 클래스 내부에서 this 바인딩

- 정적메소드 : 클래스
- 일반메소드 : 인스턴스

## Super 키워드

- 수퍼클래스의 constructor 호출
- 서브 클래스가 슈퍼클래스로부터 상속을 받으려면 무조건 서브에 super키워드 삽입해야동작함
- super.메소드로 슈퍼클래스의 메소드를 실행
- 주로 상속받을떄 사용

## Super클래스의 constructor내부의 this (자식이 상속받을시)

- this => 자식 ,new target=>자식
- 자식 클래스는 super가 반환한 인스턴스가 this바인딩

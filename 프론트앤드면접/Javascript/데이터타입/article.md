# 자바스크립트 엔진 구조

- 자바스크립트는 메모리 Heap과 CallStack으로 구성되어있다 (v8엔진)
- 싱글스레드 언어이므로 CallStack은 하나이다
- 이벤트루프를 통해 동시성을 지원한다 (싱글스레드의 문제점을 해결함)

# CallStack

- 원시형 데이터타입과, 실행컨텍스트 (스코프체인, this바인딩)가 저장된다.
- Address(식별자) , Value로구성 (Value에는 참조형데이터의 주소도 담겨있음 ,원시형 value)
- 코드의 실행순서를 관리
- 콜스택이 계속 쌓이면 스택오버플로우 발생 (재귀돌릴떄)

# Heap

- 참조형 데이터가 저장 (배열 객체)
- 동일한 참조형 데이터도 Heap의 새로운 주소에 새롭게 저장
  - let obj = { a: 1, b: 2 };
    let obj2 = { a: 1, b: 2 }; // console.log(obj, obj2);// ???

# 콜스택과 힙의 공간은 한정적이다

- 자바스크립트는 공간을 효율적으로 관리하기 위해 더이상 사용하지않는 변수나 함수를 가비지 컬렉터를 이용해서 메모리를 여유롭게 관리한다.
  - 자바스크립트의 가비지컬렉터는 Mark and Sweep 알고리즘의 원리

# 메모리누수가 생기는 경우 (메모리 낭비?)

> 어딘가에서 계속 참조하고 있다는것을 생각하면 이해하기 쉬운듯

1. 전역변수를 만드는경우

- why? : 전역 변수는 캐시에 저장되는데 캐시는 GC에 의해 수집되지않는다. 고로 use Strict를 사용하여 전역변수를 막을수있음

2. 이벤트 리스너 사용후 제거하지 않는 경우 (잘못됨)

- 현재 최신브라우저들이 메모리 누수가 발생하지 않도록 알아서 제거

3. 타이머함수 사용 (setInterval,setTimeout)

- why ? : 클리어를 해주지않으면 타이머가 계속 실행되고 있음 (참조가 살아있음)

4. 클로저 사용

5. 맵이나 객체 배열과 같은 곳에 Dom 요소를 참조하고있을경우 제거를 안해줄경우

6. 콘솔로그 사용

- 가비지 컬렉팅이 일어나지 않음

> 크롬 개발자도구를 통해 메모리 누수가되는 부분을 감지할수있음

# 참고

- https://joshua1988.github.io/web-development/translation/javascript/how-js-works-inside-engine/
- https://soldonii.tistory.com/53

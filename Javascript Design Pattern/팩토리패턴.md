# 팩토리 패턴

## 팩토리 패턴이란 ?
- 생성자 패턴에 속한다.
- 비슷한 객체를 반복적으로 생성해야 할 경우 사용한다.
- 팩토리메소드 패턴과 추상 팩토리 패턴이 있다.


### 팩토리 메소드 패턴이란 무엇일까 ?
> 객체를 만들어내는 부분을 팩토리 공장에 위임하는 패턴이다

### 팩토리 메소드 패턴이 왜 필요할까 ?
- 직접 객체를 생성하여 사용하는것을 방지 하고 서브 클래스에 역할을 위임하여 보다 효율적인 코드와 의존성을 제거할수있다. 

> 소스코드 예시
~~~ js
class Pizza {
  constructor() {}
  make (name,taste) {
    switch (name) {
        case '페퍼로니':
          return new PepperoniPizza(name,taste);
        case '파인애플':
          return new PineapplePizza(name,taste);
    }
  }
}

class PepperoniPizza {
    constructor(name,taste) {
        this.name = name
        this.taste=taste
    } 
  이름 () {
    console.log(`페퍼로니 피자`);
  }
  맛() {
    console.log(`${this.taste}`)
  }
}

class PineapplePizza {
    constructor(name,taste) {
        this.name = name
        this.taste=taste
    }
  이름 () {
    console.log(`${this.name} 피자`);
  }
    맛() {
      console.log(`${this.taste}`)
  }
}

const PizzaFactory = new Pizza();
const Pepperoni=PizzaFactory.make('페퍼로니',"짠맛")
const PineApple = PizzaFactory.make('파인애플',"단맛")

Pepperoni.이름()
Pepperoni.맛()

PineApple.이름()
PineApple.맛()
~~~
> Pizza클래스에서 원하는 피자 객체를 대신 생성하는것을 볼수있다. 

> But ! 새로운 피자를 추가할떄마다 중복되는 역할의 메소드를 재입력을 해야되서 비효율적인거 같다 이를 개선해보면 아래와 같다.

> 소스코드 
~~~ js
class Pizza{
    constructor(props) {
        this.name = props.name
        this.taste=props.taste
    }
    이름() {
        console.log(`${this.name}`)
    }
    맛() {
        console.log(`${this.taste}`)
    }

    static create(name) {
        if (name === '페퍼로니') {
            return new PepperoniPizza()
        }
        else if (name === '파인애플') {
            return new PineapplePizza()
        }

    }
}

class PepperoniPizza extends Pizza{
    constructor() {
        super({name:"페퍼로니 피자",taste:"짠맛"})
    } 
}

class PineapplePizza extends Pizza {
    constructor() {
        super({name:"파인애플 피자",taste:"단맛"})
    }
}
const 페퍼로니피자 = Pizza.create("페퍼로니")
페퍼로니피자.맛()
페퍼로니피자.이름()

~~~


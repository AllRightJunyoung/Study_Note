# Chapter 6 : 변경 가능한 데이터 구조를 가진 언어에서 불변성 유지하기 

# 읽기 동작과 쓰기 동작 이란
1. 읽기동작 : 데이터를 바꾸지 않고 정보를 꺼내는것이다 
   - 가격 가져오기
   - 이름 가져오기

2. 쓰기동작 : 데이터를 바꾼다
   - 가격 설정하기

> 쓰기 동작은 불변성 원칙에 따라 구현해야된다! (카피 온라이트의 원칙)

카피 온 라이트 적용 X
~~~ js
function remove_item_by_name(cart,name){
    var idx=null;
    for(var i=0;i<cart.length;i++){
        if(cart[i].name===name){
            idx=i
        }
    }
    if(idx!==null)
        cart.splice(idx,1)
        // 원본 배열의 변경이 적용됨
}
function delete_handelr(name){
    remove_item_by_name(shopping_cart,name)
    var total=calc_total(shopping_cart)
    set_cart_total_dom(total)
    update_shipping_icons(shopping_cart)
    update_tax_dom(total)
}
~~~ js

쓰기동작을 읽기로 바꾸기 (카피 온라이트 원칙 적용)
~~~ js

function remove_item_by_name(cart,name){
    var new_cart=cart.slice() // 새로운 배열생성
    var idx=null;
    for(var i=0;i<new_cart.length;i++){
        if(new_cart[i].name===name){
            idx=i
        }
    }
    if(idx!==null)
        new_cart.splice(idx,1)
        // 원본 배열의 변경이 적용 x
    return new_cart
}

function delete_handelr(name){
    shopping_cart=remove_item_by_name(shopping_cart,name)
    var total=calc_total(shopping_cart)
    set_cart_total_dom(total)
    update_shipping_icons(shopping_cart)
    update_tax_dom(total)
}
~~~


# 쓰기를 하면서 읽는 동작은 어떻게 구현할까?
1. 읽기와 쓰기함수로 각각 분리한다.
2. 함수에서 값을 두개 리턴한다.


1. 읽기와 쓰기함수로 각각 분리하는 예제
~~~js
// 읽기 동작

function first_element(array){
    return array[0]
}
function drop_first(array){
    var array_copy=array.slice()
    array_copy.shift()
    return array_copy
}
~~~

2. 값을 두개 리턴하는 함수로 만들기
~~~js
function shift(array){
    var array_copy=array.slice()
    var first=array_copy.shift()
    return {
        first:first,
        array:array_copy
    }
}
~~~

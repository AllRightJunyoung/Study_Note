# 데이터타입

## 기본형

- 불변성을 뛴다. immutable (변하지 않는다)
- 하나의 정보를 담고있다

1. 숫자
2. 문자열
3. 불리언
4. null
5. undefined
6. 심볼(ES6)

## 기본형 타입 변수 선언 및 할당 재할당 과정

```js
식별자에대한 주소 따로 , 식별자에 저장되는 데이터에 대한 주소 따로
var a="abc"
1. 식별자 a 를 빈공간 주소 1003에 할당 (선언) ⇒ 변수영역
2. “abc” ⇒주소 5004(빈공간)에 저장 ⇒ 데이터영역
3. 식별자 a(1003)의 값은 주소 5004를 가리키고있음 (할당) ⇒ a(1003)=5004 ⇒ 변수영역
4. a=”abcdef” , 주소 5005 : (abcdef) (재할당) ⇒ a(1003)=5005
5. 5004의 값을 사용안할시 GC에의해 사라짐
```

변수에 값을 재할당할때 기존의 주소(5004)에 새로운값을 넣는것이아닌 새로운주소(5005)에 새로운값을 넣는다.

> Why? : 만약 기존의주소에 새로운 값을 넣게 된다면 새로운값에 맞는 데이터 크기를 조정해야되므로 다른 메모리 공간에있는 값들의 영역을 침범하게 될수도 있어 다른 메모리 공간에 있는값들을 옮겨야하는데 비용이 듬)

## 참조형

- 불변성을 띄지 않음 , mutable object라고한다. 변할수있음
- 고정된 크기를 띄고있지않다
- 변수에 값이 아닌 주소를 저장하고있다.
- 동적으로 크기가 변하는데이터를 보관하기위해 다른곳에 데이터를 저장

1. 배열
2. 객체
3. 함수 (일급객체) => 변수에 할당가능 , 다른 함수를 인자로 전달받음 ,
4. Map,
5. set

## 참조형 타입 변수 선언 및 할당 재할당 과정

```js
var obj1 ={
a:1,
b:'bbb'
}
1. obj1 (식별자)주소할당  ⇒ 1002
2. obj1의 프로퍼티 들을 담을 주소 할당 ⇒ 5001
3.  객체내 프로퍼티의 주소할당 5001 ⇒ (a 7103 ,b 7104)
3. a(7103) :1 (5003) , b(7104) : 'bbb' (5004)


obj1.a =2
a 7103 : 2 (5005)


```

## 자바스크립트의 데이터 저장방식

- 자바스크립트는 매니지드 언어여서 개발자의 직접적인 메모리를 제어하는것을 허용하지않음 (c언어같이)=> 성능면에서 손실발생
- C/C++ , 자바 같은 정적 타입언어는 메모리의 낭비를 최소화하기 위해 2바이트 , 4바이트등으로 나눔
  > But 자바스크립트는 메모리 공간을 좀 더 넉넉하게 할당 , 숫자의 경우 정수형인지 부동소수점 형인지를 구분하지 않고 64비트, 8바이트로 확보

## 변수와 식별자

1. 식별자 : 어떤 데이터를 식별하는데 사용하는 이름 (변수명)

- 식별자를 통해 변수안에있는 데이터에 접근할수 있다.

2. 변수 : 변할수 있는 데이터 (데이터를저장하는공간)

## 변수 var로 선언

- 변수 선언과 초기화 단계가 동시에 일어나며 암묵적으로 메모리 공간에 undefined 할당 (런타임전)
  - 변수 선언 이전에 값을 사용할경우 undefined가 출력
  - 런타임 이전에 이미 undefined가 할당되어있음
- 함수 스코프

## 변수 let const로 선언

1. let

- 변수에 재할당 가능
- 변수 선언문 이전에 콘솔창으로 뛰으면 Reference Error (TDZ) (메모리 할당이 안되있음)
  - 선언(런타임전)과 초기화(런타임후) 단계가 별개로 진행
- 블록 스코프

2. const

- 변수에 재할당 불가능
- 블록 스코프

## 자바스크립트 변수의 특징

- 변수 호이스팅이 발생 (소스코드 실행 전 단계인 런타임 이전에서 모든 식별자를 상위로 끌어올림)
- 변수선언은 런타임 이전에 발생 , 변수할당은 런타임에 실행
- 선언이 아닌 할당에 의해 타입이 결정된다 (타입추론) =>동적타이핑
  - 재할당도 언제나 동적으로 변할수있다.

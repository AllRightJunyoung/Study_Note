# React Testing Libray
- 사용자의 애플리케이션 사용 방식으로 소프트웨어를 테스트
- 내부구현테스트를 한다 (소프트웨어가 원래대로 동작하는지)
- 스크린 리더와 다른보조 기술로 요소를 찾음
- DOM과 상호작용하기 위한 유틸리티 제공
- 브라우저 없이도 동작가능
- 기능 테스트방식위주 
> 가상 DOM을 제공하여 브라우저환경에서 사용자행위 동작으로 테스팅 가능


# Jest
- 테스트를찾고 테스트를 돌리고 pass or fail을 감지한다 (테스트러너)


## npm test
- Jest에서 Watch 모드 실행으로 시작된다


## Jest Watch Mode
- Jest를 실행하는 방법
- 마지막 커밋 이후 파일의 모든 변경사항을 확인해서 마지막 커밋 이후 변경된 파일과 연관된 테스트만을 실행한다.


1. render : 인수의 JSX에 대한 가상돔을 생성한다
  - screen global 객체로 렌더링된 가상 DOM에 액세스한다.

2.  screen 객체의 메소드
  - getByText : 표시되는 모든 텍스트를 기반으로 DOM에서 요소를 찾는다

3. expect (단언)
  - 테스트 성공과 실패의 여부를 결정한다.
- expect(linkElement).toBeInTheDocument()
  - expect (Jest의 전역메소드)
  - linkElement : 테스트를 검증하는 대상
  - toBeInTheDocument (Matcher) 단언의 유형 (문서에 해당요소가 있나 없나 확인)

4. jest-Dom
- setupTests.js 파일을 이용해 각 테스트전에 jest-dom을 가져와서 모든테스트에서 jest-dom매처를 사용할수있게됨

## TDD
- 코드 작성전에 테스트를 작성하고 테스트에 통과하도록 코드를 작성
  1. 테스트케이스 추가
  2. 모든 테스트를 실행하고 새로 추가한것이 실패하는지 확인
  3. 테스트 통과를 위한 코드작성
  4. 모든 테스트를 실행하고 전부 성공하는지 확인
  5. 리팩토링을 통해 중복 제거

## BDD
- 애플리케이션 코드 작성전 코드가 수행할 행위를 먼저 작성하는 개발 습관
- 유닛테스트 보다는 기능테스트나 엔드 투 엔드 테스트로 작성
- 어떤 행동으로 인해 일어나는 시나리오를 테스트




# 테스트 종류 (중요)
1. Unit 테스트
- 보통 함수나 별개의 React 컴포넌트 코드의 한 유닛 혹은 단위를 테스트
- 다른 코드의 유닛과 상호 작용하는것을 테스트 하지 않는다.

2. 통합테스트
- 유닛 간의 상호작용을 하는 테스트

3. 기능테스트
- 소프트웨어의 특정 기능을 테스트
  - 데이터를 폼에 입력하고 제출할 경우 소프트웨어가 특정 데이터 세트로 바르게 작동하는 기능을 확인
  > 코드가 아닌 동작을 테스팅 하는것

4. E2E테스트
- 실제 브라우저가 필요하고 애플리케이션이 연결된 서버가 필요함 (Cypress, 셀레니움)

# 기능테스트 vs 유닛 테스트
1. 유닛 테스트
- 테스트를 최대한 격리시킨다.
  - 문제가 발생하거나 테스트에 실패시 , 다른 것이 아닌 특정 유닛에 초점을 둠
- 사용자가 소프트웨어와 상호 작용하는 방식과는 거리가 멀다. 
- 컴포넌트 자체의 로직이 복잡하여 분리해야야될 상황에 사용

2. 기능 테스트
- 테스트하는 특정 동작이나 유저 플로우와 연관된 모든 단위를 포함 
- 사용자가 소프트웨어와 상호 작용하는 방식과 매우 밀접
- 디버깅이 어렵다. (어떤 부분의 코드가 테스트 실패의 원인인줄모름)


## 유닛테스팅 예제

~~~ 

describe('spaces before camel-case capital letters',()=>{
  test('Works for no inner capital letters',()=>{
    expect(replaceCameWithSpaces('Red')).toBe('Red')
  });
  test('Works for one inner capital letters',()=>{
    expect(replaceCameWithSpaces('Blue')).toBe('Blue')
  })
})

~~~
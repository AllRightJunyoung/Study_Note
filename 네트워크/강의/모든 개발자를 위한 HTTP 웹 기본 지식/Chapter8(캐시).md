# 캐시가 없을떄

1. 동일한 이미지를 서버에 계속 요청해서 가져옴
2. 브라우저 로딩속도가 느리다 (이미지를 가져와야되므로)
3. 느린사용자 경험
4. 비싼 네트워크 사용량을 발생

# 캐시가 있을떄

- cache-control을 적용
- 서버에 요청하지 않고 브라우저 캐시에서 요청하는 이미지를 가져옴
- 만약에 캐시유효시간이 초과되면 서버를 통해 데이터를 다시 조회하고 캐시를 갱신한다.

# 캐시의 유효 시간 초과임에도 서버에서 데이터를 갱신안하는방법 (요청량이줄어듬)

>캐시는 유효시간이 초과해도 사라지지않는다.  검증헤더 + 조건부 요청을 이용한다.

- Last-Modified (검증헤더) => 데이터가 마지막에 수정된 시간을 담고있음

> 캐시에 저장된것이 Last-Modified가 존재할떄 if-modified-since라는 요청 헤더를 붙이고 서버에 요청

1. 검증헤더(Last-Modified)/  if-modified-since (데이터가 마지막에 수정된시간)을 넣고 서버에 보냄
2. 서버는 날짜를 보고 데이터가 변경안된지 확인하고 변경이 안되있을시 HTTP Body 없이 헤더 메타 정보(Last-Modified와 함께) + 304 Not Modified를 보냄
3. 클라이언트는 서버가 보낸 응답 헤더 정보로 캐시의 메타정보를 갱신
4. 클라이언트는 캐시에 저장되어있는 데이터를 재활용

> 네트워크 다운로드가 발생하지만 용량이 적은 헤더 정보만 다운

# 검증 헤더

- 캐시데이터와 서버 데이터가 같은지 검증하는 데이터
- 종류 : Last-Modified ,ETAG

## 조건부 요청 헤더

- 검증헤더로 조건에 따른 분기 (If-Modified-Since:Last-Modified 사용)
- If-None-Match :ETag 사용
- 조건 만족시 200 ok ,아닐시 304 Not Modified

## If-modified-since (조건부요청)

- 서버에있는 데이터 미변경시 304 Not Modified
- 서버에있는 데이터 변경시 200 OK (모든 데이터 전송)

## ETag와 If-Node-Match 활용

- ETag(Entity Tag)
- 캐시용 데이터에 임의의 고유한 버전이름을 달아둠
- 데이터가 변경되면 이 이름을 바꾸어서 변경 (ETag:"aaaaa" -> ETag:"bbbbb")
  > 같으면 유지 다르면 다시 받음 (ETG)

## ETag 활용 예

1. 클라이언트에서 서버로 데이터 요청 (첫요청)
2. 서버는 ETag와 함꼐 전송 (첫요청)
3. 클라이언트는 브라우저 캐시에 ETag와 함께 저장 (첫요청)
4. 클라이언트는 두번째로 똑같은 jpg를 서버에 요청한다 (이떄 If-None-Match :ETAG명으로 조건부요청을함)
5. 서버는 If-None-Match에 대응되는 ETag가 있는지 확인하고 서바에서 매칭되는게 있으면 (304,Not Modified) ,없으면 200 OK (모든 데이터 전송)
